<!DOCTYPE html>

<html>
<head>
<link rel="stylesheet" type="text/css" href="../../../doc/showcases.css">
<title>Visualizing Submodule Information</title>
</head>

<body>

<h1><center>Visualizing Submodule Information</center></h1>

<h2>Goals</h2>

<p>
Complex models such as protocols are often implemented as compound modules sometimes several levels deep.
Submodules deep down in the module tree often contain information that is essential to understand model behavior.
In the graphical runtime environment, one has to enter the compound modules or drill down in the object inspector to access this kind of information. 
</p>

<p>
This example demonstrates how state information of important submodules can be visualized at containing network nodes, at the top level of the network. This visualization makes such information conveniently available at a glance, without the need to go deep into compound modules. This example contains a configuration that demonstrates visualization of IEEE MAC 802.11 contention states during the channel access procedure.
</p>

<p>
INET version: <var>3.6</var><br>
Source files location: <var>inet/showcases/visualization/info</var>
</p>

<h2>About the visualizer</h2>

<p>
The <var>InfoVisualizer</var> (included in the network as part of <var>IntegratedVisualizer</var>) module can visualize information provided by various submodules deep down in the module hierarchy. This information is visualized at the submodule of the contaning network node, typically at the top level canvas. The following image illustrates this with the example of the UDP submodule:
</p>

<img class="screen" src="example.png">

<p>
The image on the left shows the state information displayed by the UDP app. To see this, one has to go into the containing node. The image on the right shows the same information
displayed above the containing node, on the top level canvas.
</p>

<p>
The submodules whose states should be visualized can be selected with the visualizer's <var>modules</var> parameter. This parameter takes full path module names.
Wildcards can be used to select a certain submodule in multiple nodes. Additionally, one can specify multiple submodules for a node.
</p>

<p>
The visualizer can display module information in various ways, selected with the <var>format</var> parameter.
This parameter takes a format string, which can contain the following directives:

<ul>
<li>%n: module full name</li>
<li>%p: module full path</li>
<li>%d: display string text - the 't' tag of the submodule's display string</li>
<li>%i: the return value of the module's info() function</li>
<li>%s: the return value of the module's str() function, this is the default</li>
</ul>

<p>
On the example image above, the display string text is visualized, selected with the '%d' directive.
</p>

<h2>The visualization</h2>

<p>
The network for the simulation is the following:
</p>

<img class="screen" src="infonetwork.png">

<p>
It contains three <var>AdhocHosts</var> arranged in a simple chain. It also contains an <var>IPv4NetworkConfigurator</var>,
an <var>Ieee80211ScalarRadioMedium</var>, and an <var>IntegratedVisualizer</var> module. The communication ranges of hosts
is determined by their radio transmitter power, which is configured so that hosts can only reach adjacent hosts in the chain.
Hosts' routing tables are set up accordingly, thus packets going between <var>source</var> and <var>destination</var> 
are routed via <var>relay</var>.
</p>

<p>TODO: parameters should be italic for consistency</p>

<p>
The visualization is enabled by setting the <var>modules</var> parameter.
The visualizer is configured to visualize IEEE 802.11 MAC contention state during the channel access procedure. This information is contained in each node's Contention module.
The location of the Contention module is <var>somehost.wlan[*].mac.dcf.channelAccess.contention</var>:
</p>

<div class="snippet">
*.visualizer.*.infoVisualizer.modules = "*.*.wlan[0].mac.dcf.channelAccess.contention"
</div>

<p>
The <var>format</var> parameter is set to display the submodule's display string text:
</p>

<div class="snippet">
*.visualizer.*.infoVisualizer.format = "%d"
</div>

<p>
Additionally, <var>source</var> is configured to send UDP packets to <var>destination</var>.
</p>

<p>
When the simulation is run, the contention state is displayed above the nodes:
</p>

<img class="screen" src="accessstate.png">

<p>
The visualization automatically reflects the changes in the contention state. It takes on the following values:
</p>

<ul>
<li>IDLE when the node doesn't want to transmit</li>
<li>DEFER when the node wants to transmit but the channel is busy</li>
<li>IFS+BKOFF when the node is backing off while the channel is idle</li>
</ul>

<p>
The following animation illustrates as a packet from <var>source</var> makes its way to <var>destination</var>:
</p>

<img class="screen" src="info1.gif">

<img class="screen" src="info2.gif">

<p>TODO: what is happening on the animation</p>

<p>
When <var>source</var> starts transmitting the UDP packet, its state changes to OWNING.
The relay host's state is IDLE while receiving this packet. After it has received it,
the state changes to IFS+BKOFF, then, while transmitting the ACK, it changes to DEFER.
Meanwhile, the state of the source host remains OWNING, because it has the channel for the duration
of the PACKET-ACK exchange. The relay host's state is DEFER because it wants to send the packet
it just received to the destination host. After the ACK, the relay host has the channel.
The state of the destination host remains IDLE, as it doesnt want to send any packets.
</p>

<p>
The source host transmits an UDP packet to relay host, which ACKs it. While this happens,
the state of the source hosts OWNING, as it owns the channel for the duration of the packet-ACK
exchange. When the relay host receives the UDP packet, its state changes to IFS+BKOFF.
It then transmits the ACK, while its state turns to DEFER, because it already has the packet
it wants to relay to the destination host. After the ACK, the relay host gets the channel.
The state of the destination host remains IDLE, as it doesn't transmit any packets,
just ACKs the ones it receives.
</p>


<p>
Multiple submodules can be specified with the visualizer's <var>modules</var> parameter.
For example, the UDP application's state can be displayed in addition to the channel access state:
</p>

<div class="snippet">
*.visualizer.*.infoVisualizer.modules = "*.*.wlan[0].mac.ctn[0] *.*.udpApp[0]"
</div>

<p>
This would look like the following:
</p>

<img class="screen" src="multiplemodules.png">

<p>
Here, the visualizer displays the UDP application's number of sent and received packets.
</p>

<p>TODO: some kind of conclusion like in the other samples</p>

</body>

</html>