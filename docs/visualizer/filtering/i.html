<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="../../../doc/showcases.css">
<title>Filtering for Packets, Interfaces, and Nodes</title>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-240922-3', 'auto');
  ga('send', 'pageview');
</script>
</head>

<body>

<h1>Filtering for Packets, Interfaces, and Nodes</h1>

<h2>Goals</h2>

<p>
There are several visualizer types in INET, suitable for visualizing many different aspects of network simulations.
In general, all visualizer types create their visualizations in the entire network by default, and visualize all transmissions, packets, etc. This can make the
visualization cluttered in many cases. 
</p>

<p>
However, the extent of visualizations can be narrowed to increase clarity. Most visualizers have various filters, which can be set by NED parameters from the ini file.
For example, one can set filters to visualize only certain kinds of packets, at certain nodes.
</p>

<p>
This showcase demonstrates with examples the filtering features available in many visualizer modules.
</p>

<h2>Filter Types in Visualizers</h2>

<p>
There are five types of filters, and different visualizers feature a different subset of the five types.
The filters are specified by setting the visualizers' filtering parameters.
It is possible to filter for the following objects:
</p>

<ul>
<li>Network nodes</li>
<li>Interfaces</li>
<li>Modules</li>
<li>Packets</li>
<li>Ports</li>
</ul>

<h2>Filter Expressions</h2>

<p>
The filters use the cMatchExpression class internally (more information in the OMNeT++ manual). They take an expression string, which can have elements in the form of
<var>fieldName(value)</var>. The objects which match this expression will be considered in the visualization.
It is possible to write a single value without the parentheses. In this case, the value will be matched against
the object's default field, which is usually its name. Thus the following two expressions are equivalent:
</p>

<pre class="snippet">
interfaceFilter = "name(eth*)"
interfaceFilter = "eth*"
</pre>

<p>
The expressions can contain regexp-like elements: the <code>'*'</code> stands for any sets of characters, except for a <code>'.'</code> (<code>'**'</code> stands for any characters including the <code>'.'</code>). A <code>'?'</code> stands for one character.
It is also possible to use the <code>AND</code>, <code>OR</code>, <code>NOT</code> boolean operators (case insensitively). Parentheses can also be used to change the evaluation order. For example:
</p>

<pre class="snippet">
packetFilter = "*tcp* and not(*SYN* or *ACK*)"
</pre>

<p>
This matches packets that have 'tcp' in their names, but doesn't match packets with SYN or ACK in their names, basically selecting TCP packets with a payload data, and excluding ACKs and handshake packets.
</p>

<p>TODO: how it is used in visualizers. e.g. someVisualizer.packetFilter = foo</p>

<p>TODO: you can filter for the fields in the inspector panel, and any fields in the tree</p>

<p>
In the following sections, we give a few example filter expressions for each filter type.
</p>

<h2>Packet filter</h2>

<ul>
<p><li><p>Packets sent with databitrate (as opposed to controlbitrate), thus excluding ACKs. Also, only packets
whose protocol is not ICMP:</p>
<p><pre class="snippet">"bitrate(54Mbps) and not protocol(ICMP)"</pre></p></li></p>
<p><li><p>Packets that are TCP payload packets, not ACKs or part of the handshake:</p>
<p><pre class="snippet">"*tcp* and not(*ACK* or *SYN*)"</pre></p></li>
<p><li><p>Packets that are in a size range:</p>
<p><pre class="snippet">"byteLength({2000..1000000})"</pre></p></li>
<p><li><p>Packets carried by radio frames with a transmission power above a certain level:</p>


</ul>

<p>TODO: is it ok like this ? </p>

<!--
What do i want to say in here ?

- there are 5 types of filters in visualizers: network node, node, packet, interface and port
- some visualizers have parameters that are these
- they take an expression ?

They are using cMatchExpression ... is that needed ?

Examples for the 5 filter types, with 3 or 4 examples each

Some examples:

nodeFilter: where componentType.name(StandardHost) and hasIP(192.168.0.*) ?

want to select nodes that has a certain IP and





<!--
What do i want to say here?

That the visualizations in inet tipically, by default, visualize a certain aspect of the simulation
in the entiry network, at all nodes, and all packets are visualized. The scope of the visualization
can be narrowed, by filtering for nodes, network nodes, packets, interfaces, and ports.
There are 5 types of filters, and different visualizers feature a different subset of the 5 types.

Programmatically, they are xyz. Sometimes they are not called that. Is this even needed?
-->

<!--
There are filtering features that are available in many visualizers
one can filter for packets, interfaces, network nodes, modules and ports. These are the kinds that are available.
The filtering narrows the scope of the visualization for clarity. In general, these kinds are available,
but sometimes they are not called that. For example, there is the sourceFilter in xy visualizer, but it is essentially
a nodeFilter.

filters can have expressions...one can filter for the stuff that is in the inspector panel
so something like...visualize transmissions whose someField = someValue

for example, wanna visualize transmissions that have a bitrate of 24Mbps and 6Mbps

packetFilter = bitRate(24Mbps) OR bitrate(6Mbps) AND NOT packetname(ICMP)

this would visualize 24mbps and 6mbps transmissions that are not icmp messages
-->

</body>
</html>